1-1 Pass by의 개념

원시 타입과 객체 타입의 차이는 앞서 소개해드린 데이터 타입의 개념을 다룰 때 잠깐 언급을 했듯이 불변성(immutability)의 유무의 차이로 두 타입 간의 차이를 설명했는데요. 정확히 얘기하면 기존 메모리의 재할당 여부에 따라 그 차이를 보이는 경우인데, 이 장에서는 그 차이를 좀 더 명확히 설명하고자 합니다.

- 자바스크립트에서 원시 타입의 핵심은 불변성입니다. 쉽게 말해서 값이 변경 될 경우 자바스크립트 엔진은 새로운 메모리를 확보 후 재할당 작업을 거쳐 새로운 메모리의 주소에 기존의 식별자를 부여합니다. 이럴 경우 기존의 변수의 값에 새로운 값이 할당되거나, 다른 변수의 값을 대입한다고 하더라도 그 때마다 별개의 메모리 주소가 확보되기 때문에 두 변수의 원시값에는 영향을 주지 않는다(이를 두고 불변성이라고 합니다.)라는 것입니다.

```
① 원시 타입의 재할당) 기존의 Ox00000008에 80의 숫자를 지우고 100이라는 새로운 값을 할당하는 방식이 아닌, 새로운 메모리인 Ox00000016을 기존 식별자 score가 부여되고, 이 메모리에 100이 할당되게 됩니다. 그렇게 되면 기존의 메모리 Ox00000008은 식별자가 존재하지 않은채 기존의 80이 그대로 남게 됩니다. 그래서 자바스크립트는 사용하기에는 편하나 메모리 효율이 좋지 않다고 말합니다.

  let score = 80; // 식별자 score의 메모리 주소 Ox00000008에 80의 값을 할당합니다.
  score = 100; // 새로운 주소 Ox00000016를 확보하고 기존 식별자 재지정 후 그 안에 100의 값을 새로 할당.

② 기존 원시 타입에서 다른 변수로의 재할당) 기존의 변수 score의 값 80을 복사한 후 새로운 메모리 칸(주소)에 복사한 값을 할당한 후 새로운 식별자가 부여됩니다. 이렇게 될 경우 기존의 score의 값이 변경 될 경우 copy의 값은 애초에 다른 메모리를 가지고 있기 때문에 영향을 받지 않습니다. 즉 두 변수의 원시 값은 서로 다른 메모리 공간에 저장된 별개의 값이 됨으로 어느 한쪽에서 재할당을 통한 값의 변경이 발생되더라도 서로에게 영향을 주거나 간섭을 하지 않는다는 것을 의미합니다.

  let score = 80; // score 식별자가 Ox00000008 주소를 확보한 후 80을 할당합니다.
  let copy = score; // score 값 복사 후 새로운 메모리 주소에 값을 할당 후 주소를 참조합니다.

★ 식별자란 메모리 주소의 별칭 같은 느낌으로, 사용자는 복잡한 메모리의 주소를 일일이 기억하거나 부여하는 대신 식별자(별명)를 통해 쉽게 메모리 공간을 확보할 수 있습니다. 참고로 C++에서는 참조자(reference)를 통해서도 메모리 주소의 별칭 부여가 가능합니다.

```

- 반면 자바스크립트에서 객체 타입은 개수가 정해져있지 않고 동적으로 추가, 변경 및 삭제도 가능하며 프로퍼티의 값에도 제약이 없습니다. 이러한 자바스크립트에서의 객체 타입과 원시 타입의 가장 큰 차이점은 앞서 말씀드린 '불변성' 인데, 정확히 말하자면 "메모리의 재할당 작업이 이루어지지 않는다" 로 정리됩니다. 좀 더 자세히 들여다보겠습니다.

```

① 기존의 객체 선언) 자바스크립트 엔진에 의해 객체를 보관할 메모리 공간과, 그 메모리 공간의 주소를 가지고 있는 식별자를 확보합니다. 즉, 객체를 선언할 경우 실제 객체를 보관하는 메모리 공간 하나, 그 공간의 주소를 담고 있는 메모리 공간, 이렇게 두 공간이 확보되는 것이죠. 그래서 객체의 메모리에 접근할 때에는 식별자의 메모리 공간에 담긴 실제 객체 공간의 주소를 참조하여 정보에 접근하는것이 가능합니다. 

let person = {
  name: "Parkjongmin",
  age: 30,
  score: 80
}; // 객체의 정보는 Ox00001332에 보관되고, 이 주소를 OxooooooF2에 보관하고 person 식별자로 지정합니다.

person.name = "honggilldong" // 해당 값을 변경하기 위해 객체가 담긴 주소를 저장하고 있는 person 메모리 공간의 주소를 '참조' 하여 실제 객체가 담긴 메모리 공간에 접근한 후 값을 교체합니다.

① 객체 복사 후 프로퍼티 값 변경) person2에 person1를 복사할 경우 실체 객체를 저장하고 있는 주소값이 복사되기 때문에 person2의 프로퍼티 중 일부를 변경한다면 person1의 객체 정보 또한 동일하게 바뀝니다. 이는 별개의 메모리를 확보하여 실체하는 값을 저장하는 원시 타입과는 달리 실제로 객체가 존재하는 메모리의 주소를 복사하는 행위이기 때문에 결국 그 주소값을 가지고 있는 다른 식별자들 또한 변경된 값을 참조하여 보여주게 되는 것이죠. 일종의 '공유' 개념이라고 생각하면 쉽습니다.

let person1 = {
  name: "Parkjongmin",
  age: 30,
  score: 80
}; //객체 생성 후

let person2 = person1; // person1이 보관하고 있는 객체의 주소를 person2에 저장
person2.name = "김유연" // person2의 name 프로퍼티의 값을 다음과 같이 변경하면

console.log(person1) {name : "김유연" ㆍㆍㆍ} // 객체가 들어있는 메모리의 주소를 동일하게 가지고 있으므로 person2에서 변경한 값이 고대로 보여집니다.

★ 이렇듯 자바스크립트에서는 원시 값은 값에 의한 전달(pass by value)의 형식을 띄고, 객체 타입은 참조에 의한 전달(pass by reference) 형식을 띄며 이를 다른 말로 '공유에 의한 전달' 이라고도 부릅니다.

```