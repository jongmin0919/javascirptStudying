1-1 클래스란?

클래스는 ECMAScript6 에서 도입되었으며, 기존 프로토타입 기반의 객체지향 언어로서의 생성자 함수와 상속 방식의 한계점을 극복하기 위해 도입되었습니다. 이러한 클래스는 기존 생성자 함수를 기반으로하는 객체 생성 방식과 비교해서 extends와 super 키워드를 사용함으로 견고함과 명료함을 확보했다고 볼 수 있습니다. (물론 프로토타입 기반의 생성자 함수 방식보다 낫다는 것은 아닙니다.) 

정리하자면 클래스는 생성자 함수와 같이 인스턴스를 생성하는 프로토타입 기반의 객체 생성 메커니즘을 가진다고 볼 수 있습니다.

해당 클래스 생성자의 사용법은 다음과 같습니다.

1. class 키워드를 사용하며 파스칼 케이스를 사용하지 않아도 오류가 발생되지 않습니다.
2. 일반적으로 사용되는 함수 생성 방법인 익명, 기명 클래스 표기법이 가능한 일급 객체의 성격을 띕니다.
3. 클래스 몸체 내부에 선언할 수 있는 메서드는 생성자(constructor)와 프로토타입 메서드, 정적 메서드(static)이 있습니다.
4. 클래스도 변수의 선언이나 함수 정의와 마찬가지로 호이스팅이 발생됩니다. 단 let, const 키워드로 선언한 변수처럼 호이스팅이 되기 때문에 TDZ로 인해 호이스팅이 발생되지 않는 것처럼 동작합니다.
5. 클래스는 생성자 함수이므로 new 키워드와 함께 호출되어 인스턴스를 생성하는데, new 키워드가 누락되어서는 안됩니다.
6. 클래스 당 하나의 constructor만 보유할 수 있으며 생략 또한 가능합니다.(생략시 암묵적으로 생성됩니다.) 또한 constructor 내부에는 return 문을 반드시 생략합니다.
7. 프로토타입 메서드 생성시 명시적으로 선언해야하는 생성자 함수에 비해 프로토타입 프로퍼티에 직접 추가하지 않고도 기본적으로 프로토타입 메서드로 지정이 가능합니다. 그러므로 이때 클래스에 의해 생성된 인스턴스 또한 프로토타입 체인의 일원이 됩니다.
8. 생성자 함수에서 정적 메서드 생성을 위해서는 생성자 함수 앞에 메서드를 추가해야 했으나, 클래스에서의 정적 메서드 선언은 static 키워드를 사용하여 선언이 가능합니다.

```
① 기존 생성자 함수와 클래스의 정의 방식의 차이

// 생성자 함수의 생성자
funcion Person(name){
    this.name = name;
}

// 클래스의 생성자
constructor Person(name){
    this.name = name;
}

// 생성자 함수의 프로토타입의 메서드
Person.prototype.sayHello(){
    console.log(`Hi! my name is ${this.name}`)
}

// 클래스의 프로토타입 메서드
sayHi(){
    console.log(`Hi! my name is ${this.name}`)
}

// 생성자 함수의 정적 메서드
Person.sayAge = function(){
    console.log(`and my age is ${age}`);
}

// 클래스의 정적 메서드
static sayAge(){
    console.log(`and my age is ${age}`);
}

```



