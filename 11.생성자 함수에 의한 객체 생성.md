1-1 생성자 함수에 의한 객채 생성

앞서 살펴본 바와 같이 객체를 생성 함에 있어서 객체 리터럴 및 함수 리터럴에 의해 객체를 생성하는 방법도 있었는데요. 이번에는 생성자 함수를 생성하는 방법에 대해 살펴보겠습니다.

우선 앞서 살펴본 바와 같이 객체 리터럴을 통한 객체 생성은 직관적이고 간편하다는 장점을 가지고 있으나 단점 또한 존재하는데요. 단 객체 마다 공통된 프로퍼티가 존재하더라도 또 그걸 일일이 객체 안에 작성을 해주어야 한다는 단점 또한 가집니다. 즉 공통된 작업을 수행하는 코딩을 일일이 작성하는 행위를 대체하기 위해 함수를 만드는 것처럼 공통된 프로퍼티를 가지고 있는 별개의 객체들의 프로퍼티들을 일일이 작성하는 것을 대체하기 위해 우리는 생성자 함수를 활용해 객체를 생성할 수 있다는 것입니다. 

```
① 생성자 함수 선언 예시) 생성자 함수를 이용해 생성된 객체를 인스턴스라고 부릅니다.

function Person(name, age){ // 함수를 선언하듯 작성하되
    this.name = name; // 자기 참조 변수인 this 키워드를 이용해 생성하는 객체의 현재 name과 age 변수의 값을 인자로 넘어온 name과 age 값으로 할당합니다.
    this.age = age; // 여기서 this 키워드는 생성자 함수를 통해 생성하고 있는 현재의 객체를 가리킨다고 생각하시면 됩니다.
    this.introduce = function(){
        console.log(`안녕하세요~ 저는 ${this.name} 이고, 나이는 ${this.age}입니다!`)
    }
}

const person1 = new Person("Re_Go", 30); // person1 객체를 new 연산자와 생성자 함수를 작성하여 Person 함수에서 정의된 프로퍼티와 값을 가지는 객체로 생성합니다.
const person2 = new Person("김유연", 22); // 이렇게 생성된 person1과 person2는 서로 독립된 개체로서 어느 한쪽에서 값을 변경하더라도 같은 생성자 함수로 생성된 나머지 객체들의 프로퍼티에 영향을 주지 않게 됩니다.

```

- 여기서 생성자 함수 안의 this의 역할은 생성자 함수에 의해 암묵적으로 인스턴스가 생성시 생성된 인스턴스를 바인딩 하는 역할로 사용됩니다. 즉 this 뒤의 프로퍼티들은 "지금 이 객체의 프로퍼티는" 을 의미하며 이때 넘겨 받은 인자값을 저장하고 있는 매개변수의 값들을 해당 객체의 프로퍼티의 값으로 초기화 합니다. 즉 this 키워드는 생성자 함수가 각각 실행될 때마다 인스턴스를 초기화하고 새로운 객체의 속성을 설정하는 역할을 수행합니다. 이렇게 this 키워드로 생성된 각각의 객체들은 해당 프로퍼티의 값을 고유하게 갖게 되는 것입니다.

이렇게 선언 된 객체는 암묵적으로 생성자 함수를 호출한 식별자로 반환되는데, 이때 생성자 함수의 구분자 바로 앞에 빈 객체를 return 키워드로 반환하는 코드를 작성 시 생성자 함수의 앞의 작업은 무시된 채 빈 객체가 반환되며, 원시 값을 return 키워드로 반환하는 코드를 작성 시 원시 값 반환은 무시되고 암묵적으로 this에 의해 바인딩 된 객체가 반환된다는 점을 주의해야 합니다.

1-2 constructor와 non-constructor의 구분

함수 객체 중 내부 메서드 [[Call]]을 갖고 있는 함수 객체를 callable이라고 하고, [[Construct]] 를 가지고 있는 함수 객체를 constructor라고 하는데요. 호출할 수 없다면 그것은 곧 함수 객체가 아니므로, 모든 함수 객체는 반드시 calleable이어야 합니다. 하지만 모든 함수 객체들이 [[Construct]] 내부 메서드를 가지고 있는 것은 아니며 이 [[Construct]] 내부 메서드의 보유 여부에 따라 constructor와 non-constructor을 구분 짓습니다. 정리하자면 모든 함수 객체는 호출할 수 있으나, 그렇다고 모든 객체를 생성자 함수로서 호출할 수 있는 것은 아니라는 것입니다.

가장 쉽게 이 둘을 구분 짓는 방법은 함수 선언의 종류에 의한 방법으로, constructor는 함수 선언문, 함수 표현식, 클래스를 의미하고, non-constructor는 ES6 메서드의 축약 표현에 의한 메서드, 화살표 함수가 해당 됩니다.

```
① 함수 선언문에 의한 constructor 생성 예시)

function Person(name, age) {
  this.name = name;
  this.age = age;
}

const person1 = new Person("Re_Go", 30);
console.log(person1); // Person { name: 'Re_Go', age: 30 }


② 화살표 함수로 constructor 생성 시도 예시)

const Person = (name, age) => {
  this.name = name;
  this.age = age;
}

const person1 = new Person("Re_Go", 30); // 에러 발생!


```

1-3 new 연산자

new 연산자로 함수 객체를 호출시 해당 함수는 생성자 함수로서 동작되는데, 이때 함수 객체의 내부 메서드인 [[Call]]이 호출되는 것이 아니라 [[Construct]]가 호출됩니다. 만약 new 연산자 없이 함수 객체를 호출한다면 [[Call]]이 호출되어 일반 함수로 호출이 되는 것이죠.

이렇게 new 연산자와 함께 생성자 함수로서 함수 객체를 호출하게 되면 함수 내부의 this 키워드는 생성자 함수가 생성할 인스턴스를 가리키게 됩니다. (앞전의 this 설명 참조) 그리고 이러한 new 연산자 없이 호출되는 것을 방지하기 위해 생성자 함수의 이름을 파스칼 케이스로 지정하는 컨벤션을 사용하여 new 연산자의 누락을 방지하는 방법이 존재하더라도 생성자 함수를 이용해 인스턴스를 생성할 때 실수로 new 연산자를 빼먹을 수 있습니다. 

그래서 ES6에서는 이러한 상황을 방지하고자 new.target 메타 프로퍼티를 활용하여 new 연산자와 함께 생성자 함수를 재귀 호출하는 작업을 수행할 수 있도록 하는 코드를 구현하기도 합니다.

```

function Person(name, age) {
  if(new.target === undefined){ //만약 이 함수가 new 연산자와 함께 호출되지 않았다면 new.target은 undefined 입니다.
    return new Person(name,age); // 조건이 참일 경우, 즉 new 연산자 없이 호출 된 경우 연산자와 함께 Person 생성자 함수를 재귀 호출하여 생성된 인스턴스를 반환하도록 합니다.
  }
  
  this.name = name;
  this.age = age;
}

const person1 = Person("Re_Go", 30); // new 연산자 없이 생성자 함수를 그대로 호출
console.log(person1); // Person { name: 'Re_Go', age: 30 }

```

- 참고로 대부분의 빌트인 생성자 함수는 new 연산자와 함께 호출되어는지를 확인한 후 적절한 값을 반환하기 때문에 new 연산자 없이 생성 되더라도 new 연산자와 함께 호출되어 반환되는 값과 동일한 값을 반환하는대에 반해, String, Number, Boolean 빌트인 함수는 new 연산자 없이 호출시 각각의 인자값을 그에 맞는 '문자열', '숫자형', '불리언형' 으로 반환하기 때문에 이러한 형질을 이용해 특정 변수의 값이나 리터럴 값들을 형변환 하는대에도 사용합니다.

