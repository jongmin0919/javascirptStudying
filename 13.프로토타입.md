1-1 객체지향 프로그래밍의 역사

자바스크립트는 클래스 기반의 객체지향 프로그래밍 언어보다 효율적이며, 더 강력한 객체지향 프로그래밍 능력을 지니고 있는 프로토타입 기반의 객체지향 프로그래밍 입니다. 이는 원시 타입을 제외한 나머지 값들이 객체인 것을 보면 더욱 명확히 알 수 있는데요. 이를 좀더 알기 위해서는 객체지향 프로그래밍이 등장한 배경에 대해 알아볼 필요가 있습니다. 

객체지향 프로그래밍은 프로그램을 명령어 혹은 함수의 목록으로 보는 전통적인 명령형 프로그래밍의 특성인 절차지향적 관점에서 탈피하여 여러 개의 독립적 단위, 즉 객체의 집합으로 프로그램을 표현하려는 패러다임입니다. 이러한 객체지향 프로그래밍의 관점은 실체에 대한 속성을 구별하는 관점이 핵심이며, 하나의 대상이 가지는 여러 개의 속성 중 필요한 속성망 간추려 표현해내는 것을 추상화(absctaction) 이라고 합니다.

```

① 특정 대상(사람)의 인적사항(속성)을 추상화한 예시) 즉 객체는 속성을 통해 여러 개의 값을 하나의 단위로 구성하는 복합적인 자료구조를 뜻하며, 객체지향 프로그래밍은 이러한 독립적인 객체의 집합으로 프로그램을 표현하고자 하는 프로그래밍 패러다임인 것입니다.

const rego = { //rego 라는 사람은
    name : "Parkjongmin", // 이름이 다음과 같고
    age : 30, // 나이는 다음과 같으며
    address : "Seoul" // 주소도 다음과 같은 인적사항(속성)을 가지고 있다.
};

console.log(rego); // rego라는 객체(대상)의 이름과 나이, 주소라는 속성과 그 값을 출력합니다.

```

- 이처럼 객체지향 프로그래밍은 객체의 상태를 나타내는 데이터와 그 데이터를 조작할 수 있는 동작을 하나의 논리적인 단위로 묶어 생각합니다. 즉 객체는 상태 데이터(프로퍼티)와 동작(메서드)을 하나의 논리적인 단위(객체)로 묶은 복합적인 자료구조인 것이죠.

1-2 상속의 정의

이러한 객체지향 프로그래밍의 핵심은 단연 '상속' 이라고 해도 과언이 아닐 것인데, 이는 어떤 객체의 프로퍼티 혹은 메서드를 다른 객체가 상속 받아 그대로 사용하는 것을 뜻합니다. 이는 기존의 데이터를 상속 받아 불필요한 중복 데이터의 남용을 막는데 보다 효과적인 방법이죠.

즉 생성자 함수에 의해 생성된 각각의 인스턴스들은 생성자 함수의 메서드들 또한 각각 가지고 있을텐데, 이러한 메서드들을 굳이 각각 가질 필요 없이 자신의 상위 객체(부모이자 생성자 함수의 prototype)로부터 메서드를 상속 받아 공유하듯 사용하면 굳이 공통되는 작업을 개별 인스턴스가 각각 가질 필요가 없어지므로 이것이 바로 상속이 가지는 강점이라고 할 수 있습니다.

```

① 프로토타입을 사용해 특정 함수를 상속 받는 전형적인 예시 코드) 여기서 Circle.prototype의 의미는 각 인스턴스들의 부모 객체로 이해하면 쉽습니다.

function Circle(radius){
    this.radius = radius;
} // 각 인스턴스마다 고유한 원의 반지름 값을 가지고 있되

Circle.prototype.getArea = function(){ // Circle 함수의 상속 메서드를 구현하여
    return Math.PI * this.radius ** 2; // 원의 둘레를 반환하는 코드를 구현하면
}

const circle1 = new Circle(1);
const circle2 = new Circle(2); // 각각 1과 2를 반지름으로 갖고 있는 circle1와 2 인스턴스를 생성시

console.log(circle1.getArea === circle2.getArea); // 원 1과 2는 같은 함수 내에서 동일한 메서드를 상속을 받고 있으므로 true값이 출력되고

console.log(circle1.getArea());
console.log(circle2.getArea()); // 각각의 인스턴스는 상속 받은 메서드를 이용해 각자의 원의 둘레를 구할 수 있게 됩니다.


```

1-3 프로토타입?

앞서 살펴본 바와 같이 각 인스턴스들은 부모 객체인 프로토타입으로부터 특정 변수나 메서드를 상속받을수 있었음을 확인할 수 있었습니다. 그리고 이러한 프로토타입은 인스턴스들 뿐만 아니라 모든 객체들이 가지고 있는데, 직접적으로(내부 슬롯에) 접근하는 것은 어려우나, __proto__  접근자 프로퍼티를 사용해 프로토타입 프로퍼티의 내부 슬롯이 가리키고있는 프로토타입에 간접적으로 접근할 수 있습니다. 앞서 살펴본 일급 객체에서의 프로퍼티들 중 __proto__ 접근자 또한 일급 객체(함수)가 가지고 있는 프로퍼티 중 하나였으며, 

프로토타입 객체는 자신의 constructor 프로퍼티를 통해 객체를 생성한 생성자 함수에 접근할 수 있습니다. 이것은 프로토타입 객체가 어떤 생성자 함수로부터 파생되었는지를 나타내는데 사용됩니다.

즉 이러한 프로토타입에 접근하기 위해서는 부모인 생성자 함수를 통해 해당 프로토타입의 변수나 메서드를 접근하게 되고, 이때 사용되는 것이 객체마다 갖고 있는 접근자 프로퍼티(__proto__) 라는 것인데요. 그럼 왜 접근자 프로퍼티를 사용하여 프로토타입에 접근을 해야하는지에 대한 궁금증이 자연스럽게 생길 수 있을텐데, 그 이유는 상호 참조에 의해 프로토타입 체인이 생성되는 것을 방지하기 위해서 입니다. 

프로토체인은 단방향 링크드 리스트, 즉 한쪽 방향으로의 검색만 가능하도록 구현이 되어야하는데, 부모 객체와 자식 객체를 서로 프로토타입으로 지정해 버리면 해당 관계의 프로토체인은 순환 참조의 형태를 띄게 되고 이후에 프로퍼티를 검색할 때 무한 루프에 빠지게 됩니다. 그래서 __proto__ 접근자 프로퍼티를 사용하여 프로토타입에 접근하고 교체하도록 구현되어 있는 것이죠.

하지만 이러한 접근자 프로퍼티는 코드 내에서 직접 사용하는 것은 권장되지 않으며, 만약 프로토타입의 참조를 취득하고 싶은 경우, Object.getPrototypeOf 메서드를 사용하고, 프로토타입을 교체하고 싶을 경우 Object.setPrototypeOf 메서드 사용이 권장됩니다.



```

① 접근자 프로퍼티를 활용하여 객체의 프로토타입을 얻어오고, 다시 설정하는 코드 예시)

const obj = {};
const parent = {x : 1};

obj.__proto__; // obj의 프로토타입을 getter 함수를 통해 확인
obj.__proto__ = parent; // obj의 프로토타입을 setter 함수를 통해 parent로 지정

console.log(obj.x); // obj는 부모 객체인 parent의 x변수를 상속 받게 됨.

② Obj의 프로토타입 접근 메서드를 활용한 프로토타입 설정 코드 예시)

const obj = {};
const parent = {x : 1};

Object.getPrototypeOf(obj); // Object 빌트인 객체의 getPrototypeOf 메서드를 이용해 obj의 프로토타입을 확인.
Object.setPrototypeOf(obj, parent); // 다시 Object의 setPrototypeOf 메서드를 이용해 obj의 프로토타입을 parent로 설정하면 parent에 선언되어있는 변수와 메서드 등을 상속받게 됩니다. 

console.log(obj.x); // obj는 parent의 변수를 성공적으로 상속.

```

- 이러한 프로토타입의 생성 시점은 생성자 함수가 생성되는 시점에 같이 생성됩니다. 이는 생성자 함수와 프로토타입이 쌍으로 존재하기 때문인데요. 앞서 설명한 constructor를 가지지 않고 있는 메서드 축약 표현에 의한 함수나 화살표 함수를 제외하고 나머지 함수 종류를 통해 new 키워드와 같이 생성자 함수가 생성될 경우 이때 프로토 타입 객체도 같이 생성되게 됩니다. 이때 생성된 프로토타입도 원시값을 제외한 다른 값들과 마찬가지로 객체이며, 오직 constructor 프로퍼티만을 가지게 됩니다. 이렇게 생성된 프로토타입 객체에 상속 변수나 상속 함수를 만들게 되면 생성자 함수에 의해 생성된 인스턴스들은 생성자 함수의 프로토타입 객체가 가지고 있는 상속 변수나 함수를 참조하여 공통적으로 사용할 수 있게 되는 것입니다. 

물론 빌트인 생성자 함수도 일반 함수와 마찬가지로 빌트인 생성자 함수가 생성되는 시점에 프로토타입 객체를 갖습니다. 그리고 이러한 모든 빌트인 생성자 함수는 코드가 실행되기 전 자바스크립트 엔진에 의해 생성되는 특수한 객체인 전역 객체(global 객체가 대표적)가 생성되는 시점에 생성됩니다.

```

① constructor 함수의 프로토타입 생성 시점) 호이스팅에 의해 함수는 런타임 이전에 정의되고, 이때 정의된 시점에서 프로토 타입 또한 생성되게 됩니다.

console.log(Person.prototype);

function Person(name){
    console.log(name);
}

② non-constructor 함수의 프로토타입 생성 시점) non-constructor는 프로토타입을 생성하지 않기 때문에 해당 함수를 통해 prototype의 정보를 확인하려 할 때 undefined를 반환 받습니다.

const Person = name =>{
    this.name = name
    return console.log(`저는 ${this.name} 입니다.`)
}

console.log(Person.prototype); // undefined 반환.

```

1-4 객체의 생성 방식과 이에 따른 프로토타입 객체의 결정

객체를 생성하는 방법은 다양하게 존재합니다. 객체 리터럴로 직접 생성할 수도 있고, 빌트인 생성자 함수 중 하나인 Object와 new 연산자를 함꼐 사용해 객체를 활용하거나, 일반 생성자 함수를 사용하거나, Object의 메서드중 하나인 create로 객체를 생성하거나, ES6에 도입된 클래스를 통해 객체를 생성하는 방법등이 대표적으로 거론됩니다.


```
① 객체 리터럴에 의해 생성된 객체와 프로토타입) 객체 리터럴로 객체를 생성될때 자바스크립트 엔진은 추상 연산을 수행하는 OrdinaryObjectCreate에 전달하는 프로토타입으로 Object의 프로토타입 객체를 전달하게 됩니다. 그 이유는 객체 생성시 해당 객체의 타입이 자바스크립트 엔진에 의해 Object로 취급되며, 즉 Object 빌트인 생성자 함수에 의해 생성된 인스턴스(객체)로 취급되기 때문에 당연히 Object의 프로토타입 객체를 상속받아 그 객체가 가지고 있는 프로퍼티와 메서드들을 사용할 수 있게 됩니다.

const obj = {x : 1} // 타입은 Object이므로 Object.prototype을 상속받게 됩니다.

② Object 생성자 함수에 의해 생성한 객체와 프로토타입) 객체 리터럴로 객체를 생성을 할 경우 마찬가지로 자바스크립트 엔진은 추상 연산을 호출하면서 Object.prototype을 전달합니다. 즉 객체 리터럴로 생성한 객체와 동일한 프로토타입을 갖게 된다는 것이죠.

const obj  = new Object();
obj.x = 1;

③ 생성자 함수에 의해 생성된 객체와 프로토타입) 생성자 함수에 의해 인스턴스가 만들어질떄 자바스크립트 엔진은 추상 연산에 해당하는 생성자 함수가 정의될 때 같이 만들어진 프로토타입을 보내게 됩니다. 그리고 이렇게 생성된 인스턴스는 해당 생성자 함수의 프로토타입 객체의 프로퍼티와 메서드를 공유하게 됩니다. 이때 프로토타입 객체에는 constructor 프로퍼티만을 가지게 됩니다.

function Person(name){
    this.name = name;
}

Person.prototype.sayHello = function (){
    console.log(`안녕하세요. 저는 ${this.name} 입니다!`);
}

const me = new Person('Lee');
const you = new Person('kim');

me.sayHello(); // 객체 각각의 값은 별개이되 프로토타입 메서드는 공유하므로 정상적으로 사용 가능.
kim.sayHello();

④ Object.create 메서드에 의해 생성된 객체의 프로토타입)Object.create에 의해 특정 객체의 인스턴스를 생성 후 obj 변수에 할당합니다. 이때 선택된 변수가 객체일 경우 Object.prototype이 선택되는데, 만일 배열이라고 한다면 Array.prototype 을 상속받게 될것입니다. 즉 Object.create에 의해 생성 된 인스턴스는 전달 된 객체의 상태에 따라 프로토타입 또한 바뀌게 됨을 의미합니다. 정리하자면 첫번째 매개변수는 상속 받을 프로토타입이나 객체를, 두번째 값은 생성될 해당 인스턴스의 프로퍼티를 정의하여 직접적으로 프로토타입을 상속 받을 수 있기에 편리한 기능이라고 할 수 있습니다. 

단 모든 객체들은 프로토타입 체인의 종점인 Object.prototype이기에 이 프로토타입에 포함되어있는 여러 메서드들을 사용할 수 있으나, 직접적으로 프로토타입을 null로 설정할 경우, 해당 메서드들을 사용할 수 없기에 Object.create를 통해 상속 받을 프로토타입을 직접 설정해주는 방법에 주의가 필요합니다. 이렇게 프로토타입이 null로 선언된 인스턴스의 프로퍼티를 확인할 경우, Object.prototype.hasOwnProperty.call(obj, 'obj의 특정 키') 이런 식으로 찾을 수 있습니다.

const obj = { x: 1 }; // obj 상수를 객체 데이터로 생성 후
const numberIs = Object.create(obj); //  Object.create 메서드로 obj를 프로토타입으로 하는 numberIs 인스턴스 객체를 생성합니다. 이 경우 obj의 x값을 상속 받는데, 주의할 점은 obj를 직접 상속 받는 또 다른 인스턴스가 있을 경우 값을 공유하기 때문에 주의를 해야할 필요가 있습니다.
const numberIs2 = Object.create(Object.prototype, { // 또한 첫번째 매개변수는 지정할 프로토 타입, 두번째 매개변수는 값과 그에 대한 데이터프로퍼티를 설정할 수 있습니다.
  x : {value : 1, writable : true, enumerable : true, configurable: true}
});

⑤ class에 의해 생성된 객체의 프로토타입) class에 의해 생성된 인스턴스는 class.prototype를 상속하게 됩니다.
단 클래스에 프로토타입 메서드를 직접 선언하는 방법은 ES6 클래스 문법에서 지원되지 않기 때문에 프로토타입 상속을 이요한 메서드 공유를 의도하게 된다면 class보다는 그냥 생성자 함수를 사용하는 방법을 권장합니다.


```

1-5 프로토타입 체이닝

자바스크립트는 객체의 프로퍼티에 접근하려고 할 때 객체에 접근하려는 프로퍼티가 없을 경우, [[Prototype]] 내부 슬롯의 참조를 따라 자신의 부모 역할을 하는 프로토타입의 프로퍼티를 순차적으로 검색하는데 이를 프로토타입 체인이라고 하며 이는 자바스크립트의 객체지향 프로그래밍의 상속을 구현하는 메커니즘이기도 합니다. 

그리고 이러한 프로토타입 체이닝에 입각해 객체가 특정 프로퍼티나 메서드를 찾는 과정은 다음과 같습니다.

1. 먼저, 인스턴스 내부에서 해당 메서드 또는 프로퍼티를 찾습니다. 즉, 인스턴스가 직접 해당 메서드 또는 프로퍼티를 가지고 있는지 확인합니다.
2. 인스턴스 내에서 찾지 못한 경우, 해당 생성자 함수의 프로토타입 객체를 확인합니다. 생성자 함수의 프로토타입 객체에 해당 메서드 또는 프로퍼티가 있는지 확인합니다.
3. 생성자 함수의 프로토타입 객체에서도 찾지 못한 경우, 프로토타입 체인을 따라 상위 프로토타입 객체를 확인합니다. 이 과정에서 상위 프로토타입 객체는 상속 체인의 다음 단계에 해당합니다.
4. 최종적으로 Object.prototype까지 이동하여 해당 메서드 또는 프로퍼티가 있는지 확인합니다. Object.prototype은 모든 객체의 기본 프로토타입이므로, 모든 객체가 이를 상속합니다.

이런 이유로 Object.prototype을 체인상 최상위에 있다고 하며, 만약 Object.prototype에도 찾고자 하는 메서드나 값을 검색할 수 없다면 undefined가 반환되게 됩니다. 만약 이러한 프로토타입 체이닝에 해당 인스턴스가 연결 되었는지에 대해 확인해보려면 instanceof 연산자로 확인이 가능함을 알아두시면 좋습니다.

- 반면 식별자를 검색할 경우 프로토타입 체이닝이 아닌 스코프 체이닝은 입각하여 검색하므로 이 체이닝은 식별자가 선언된 위치가 함수 레벨 스코프 지역인지, 블록 레벨 스코프 지역인지(9.스코프 참조)에 따라 검색 위치와 순서의 방향을 정하게 된다는 점을 알아두시면 좋은데, 이러한 스코프 체이닝과 프로토타입 체이닝은 서료 연관없이 별도로 동작하는 것이 아니라 서로 협력하여 식별자와 프로퍼티를 검색하는데 사용된다는 점을 알아두시는게 핵심입니다.

1-5 오버라이딩과 프로퍼티 섀도잉

이런 상상을 해보셨나요? 만약 생성자 함수의 프로토타입 객체에서 소유한 메서드를 인스턴스가 같은 이름으로 선언해버린다면 어떻게 될까? 이때 인스턴스에는 해당 메서드를 소유하게 될텐데, 이후 인스턴스에서 해당 메서드를 호출할 경우 프로토타입 체이닝에 의해서 프로토타입 객체에서 상속 받는 메서드가 아니라 인스턴스가 소유한 메서드를 검색하게 됩니다. 이렇게 마치 상속 받는 메서드를 가려버리는 현상을 오버라이딩 이라고 하며 이때 프로토타입에서 인스턴스에 상속을 주는 메서드가 가려지는 현상을 프로퍼티 섀도잉 이라고 정의합니다.

즉 인스턴스가 상속 받는 프로퍼티나 메서드를 가려버리면 오버라이딩, 프로토타입 프로퍼티나 메서드가 가려질 경우에는 프로퍼티 섀도잉으로 정의를 내린다는 것이죠.

이러한 현상을 막아주기 위해서는 무엇보다 인스턴스에서 상속 받는 메서드와 같은 이름으로 메서드를 재선언 하는 행위를 지양하는게 좋지만, 만들게 되었을 경우 delete로 깔끔하게 지워버리면 됩니다. 이때 알아두면 좋은 점은 인스턴스의 메서드를 삭제 후 다시 한번더 같은 메서드 이름으로 delete를 호출할 경우 프로토타입 객체의 메서드가 삭제되지 않는다는 것인데요. 이는 인스턴스가 상속을 받는 행위(get)는 할 수 있어도 그 상속값을 처리하는 행위(set)는 할 수 없음을 의미하기도 합니다.

```

function Person(name) {// Person 생성자 함수 정의
    this.name = name;
}
    
Person.prototype.sayHello = function() { //Person 생성자 함수의 프로토타입 객체에 sayHello 함수 정의
    console.log(`Hi! My name is ${this.name}`);
};

const me = new Person('Lee'); // Person 생성자 함수로 me 인스턴스를 생성

me.sayHello = function(){ // me 인스턴스에 프로토타입으로 상속 받는 메서드 sayHello와 동일한 이름으로 생성
    console.log(`Hi! My name is ${this.name}`);
}

me.sayHello(); // 이 경우 인스턴스에서 상속 받는 메서드가 아니라 인스턴스에서 직접 생성한 메서드가 호출됩니다.

delete me.sayHello(); // 이러한 인스턴스의 메서드를 지우고 싶다면 delete 연산자로 인스턴스가 가지고 있는 메서드를 삭제하면 오버라이딩과 섀도잉 현상을 해결할 수 있습니다.

delete me.sayHello(); // 만약 사용자가 프로토타입 메서드까지 삭제하려고 delete를 다시 호출했다면 이는 무효화 됩니다. 값을 읽어올 수는 있지만 수정할 수는 없기 때문입니다.

```

1-6 프로토타입의 교체

프로토타입을 교체하는 것이 가능할까요? 가능합니다. 하지만 그럴 경우 기존의 생성자 함수의 프로토타입이 가지고 있던 constructor는 사라지게 되므로 이때 생성자 함수에 의해 생성된 인스턴스가 상속받는 프로토타입 객체는 생성자 함수의 프로토타입이 아닌 그 위에 최상위 객체이자 constructor 프로퍼티를 가지고 있는 Object.prototype이 됩니다.

```
function Person(name) {
    this.name = name;
}

const me = new Person('John');

// 새로운 프로토타입 객체를 생성하고 교체
Person.prototype = {
    sayHello: function() {
        console.log(`Hello, my name is ${this.name}`);
    }
};

const you = new Person('Alice');

me.sayHello(); // 에러 발생, sayHello 메서드를 찾을 수 없음
you.sayHello(); // "Hello, my name is Alice" 출력

console.log(me.constructor === Person); // Person의 프로토타입이 변경 되기 전인 상태에서 constructor를 가지고 있으므로 true를 반환
console.log(you.constructor === Object); // Person의 프로토 타입이 객체 리터럴로 바뀐 시점에는 constructor가 없는 상태이므로 자동적으로 그 상위 부모인 Object의 프로토타입 객체가 가진 constructor에 의해 Object.prototype과 연결되게 되므로 true를 반환.

```

- 만약 이러한 문제를 해결하고 싶다면 변경하는 프로토타입에 constructor 키워드로 프로퍼티와 생성자 함수간의 연결을 설정하면 해결됩니다.

```
function Person(name) {
    this.name = name;
}

const me = new Person('John');

Person.prototype = {
    constructor: Person, // 이 프로토타입 객체의 메서드를 만든 주체가 Person임을 의미하도록 constructor를 Person으로 지정합니다.
    sayHello: function() {
        console.log(`Hello, my name is ${this.name}`);
    }
};

const you = new Person('Alice');

me.sayHello(); // 에러 발생, sayHello 메서드를 찾을 수 없음
you.sayHello(); // "Hello, my name is Alice" 출력

console.log(me.constructor === Person); // true;
console.log(you.constructor === Person); // true;

```

- 정리하자면, 체이닝이 생성자 함수의 프로토타입 변경에 의해 constructor 프로퍼티와 생성자 함수 간의 연결이 파괴되 경우 해당 인스턴스와 생성자 함수 간 constructor 연결 여부는 false를 반환 하더라도 체이닝 상에는 아직 존재를 하고 있기에 앞서 짧게 소개한 instanceof 연산자로 해당 인스턴스가 생성자 함수의 인스턴스인지 여부를 검색할 경우 true값을 반환받게 됩니다.