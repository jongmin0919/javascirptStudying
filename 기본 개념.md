1-1 변수(식별자)란?

메모리 공간에 저장된 값을 식별할 수 있는 각각의 고유한 이름을 변수(variable) 라고 부릅니다. 또한 이 변수에 저장된 실제하는 값을 변수 값(value) 이라고 부르며, 변수 안에 있는 변수의 값 읽어오는 작업을 참조(reference)라고 합니다. 즉 사용자의 요청에 의해 자바스크립트 엔진은 변수의 이름과 매핑 되어있는 메모리 주소를 참조해 공간에 접근하여 저장된 값을 읽거나, 복사하는 작업을 수행하게 되는 것이죠. 

특히 이 변수는 값이 저장되어 있는 메모리 공간을 부르는 별칭으로도 사용되나, 그 값이 저장되어 있는 메모리의 주소를 가리키기도 하고 있다는 점에서 '식별자' 라고도 부릅니다. 

1-2 변수 선언

변수 선언(variable declaration)은 이러한 변수를 생성하는 작업을 의미하며, 정확히는 값을 저장하기 위해 메모리의 특정 공간을 확보하고 변수 이름과 메모리 공간의 주소를 연결하면서 값을 저장할 수 있도록 준비하는 작업을 의미합니다. 그리고 이렇게 확보 된 메모리 공간은 어떠한 메모리 공간에 확보했느냐에 따라 사용자가 신경 쓸 필요 없이 메인 작업이 끝나면 자동으로 해제가 되기도 하고(stack), 사용자가 직접 해제를 해주어야 하는 경우(heep)의 수를 생각하면서 사용자가 적절한 변수를 적절한 메모리 공간에 선언하는 것 또한 중요합니다.

1-3 변수 선언 방법

자바스크립트는 기본적으로 다른 언어와는 달리 따로 자료형을 변수 앞에 네이밍하지 않습니다. 즉 변수를 선언 할때 할당하는 값에 따라 해당 변수의 타입이 바뀐다는 점에서 다른 정적 프로그래밍 언어와는 차별화를 보이는 동적 프로그래밍 언어인데요. 이러한 자바스크립트를 이용해 변수를 선언시 흔히 세 가지 키워드인 'var', 'const', 'let' 키워드를 사용합니다. 각각의 키워드에 대한 설명은 다음과 같습니다.

var : 자바스크립트의 초기부터 변수를 선언할 시 사용된 키워드 입니다. 이 키워드의 단점으로 인해 향후 ES6에서 let과 const가 등장하게 되는데요. 이 키워드는 다른 키워드들과 마찬가지로 변수를 선언함에 있어서는 크게 무리가 없으나, 중복 키워드를 선언하면 이미 선언되어있던 키워드의 정보 위에 덮어씌어 버린다는 치명적인 단점을 가진 키워드 입니다. 이는 공동프로젝트 및 협업에 있어서 매우 안 좋은 경우를 초래하게 만들 수 있으며, 블록 및 함수 레벨 스코프의 개념을 무시하여 함수 내부에서만 사용 가능한 값을 바깥 스코프 에서도 사용이 가능하게 하는 불상사를 만들어내기 때문에 여러모로 안좋은 키워드 입니다.

```
① var name1 = "musicArtistsChannel" -> 최초 변수 선언 후 
  var name1 = "historyChannel" -> O 같은 키워드로 똑같이 선언 가능.

```

let : var이 가지는 치명적인 단점을 보완하고자 const와 함께 등장한 키워드 입니다. let 키워드는 한번 선언한 변수의 이름은 같은 키워드로 다시 선언이 불가능하며, 이 키워드의 등장으로 변수 관리와 오류 수정에 보다 용이한 블록 레벨 스코프의 개념 적용도 가능해졌습니다.

```
① let name1 = "musicArtistsChannel" -> 최초 변수 선언 후 
  let name1 = "historyChannel" -> X 중복으로 변수를 선언하는 것은 불가.
② name1 = "historyChannel" -> O 이미 선언 된 변수에 다른 값으로 초기화 하는 것은 가능.
③ let name2; -> 변수를 선언만 해주고 초기화를 하지 않을 경우 undefined 값으로 초기화되며
  name2 = "natureParkChannel" -> O 이후에 다른 값으로 할당하는 것이 가능합니다.

```

const : ES6에서 let과 등장하였으며, 큰 틀에서는 let과 별 차이가 없으나 가장 강력한 점을 꼽자면, 한번 대입한 값을 다른 값으로 수정 할수 없다는 것입니다. 그래서 const로 선언한 변수를 흔히 '상수(항상 있는 값)' 이라고 통상적으로 부릅니다.

```
① const name1 = "musicArtistsChannel"
  name1 = historyChannel -> X 한번 할당 된 값은 다른 값으로 재할당이 불가능하며
② const name2; -> X let과 달리 변수를 선언하면서 동시에 값을 할당(초기화) 해주어야 합니다.

```

2-1 값의 할당

앞서 소개한 변수 값은 변수를 선언할 때 할당이 가능하고, 선언만 해놓고 후에 할당하는 것 또한 가능하며, 기존의 변수에 저장되어 있던 값을 재할당 하는 것도 가능합니다. 여기서 주의할 점은 값을 재할당 할 때 기존의 메모리 공간을 차지하고 있던 값을 삭제하고 다른 값을 넣는 것이 아니라, 다른 메모리 공간을 변수(식별자)가 확보한 후 그 메모리 공간에 새로운 값을 할당하는 방식입니다.

```
① let name1 = "memoryPlace1" -> 만약 메모리 주소가 Ox00000004 라고 한다면
  name1 = "memoryPlace2" -> "memoryPlace2"는 기존 값이 가지고 있던 Ox00000004 공간이 아닌, Ox00000008이나 다른 메모리 공간에 할당 되는 것입니다.

```

3-1 호이스팅?

호이스팅(Hoisting)이란 변수 및 함수 선언을 컴파일 단계에서 해당 코드가 상단으로 끌어올려지듯하는 현상을 의미합니다. 자바스크립트의 코드 해석방식은 한 줄씩 차례대로 실행하는 인터프리터 방식인데, 이때를 가리켜 런타임(Runtime)이라고 부르고, 이 런타임 이전에 변수의 선언이나 함수 선언이 해당 스코프(범위)의 상단으로 끌어올려져 선언을 하지 않았음에도 선언이 되어있는듯한 느낌을 주게 만듭니다. 하지만 값은 undefined로 할당이 되죠.

```
① console.log(value); -> undefined출력) 런타임 전에 선언된 value 변수는 사용이 가능하나

② let value = "koreanChannel" -> 값의 할당은 실제 런타임 때에 동작 됩니다.

③ console.log(value); -> koreanChannel출력) 이후 할당 된 값이 정상적으로 출력됩니다.
```

그래서 이러한 호이스팅 현상은 사용자가 따로 해당 변수나 함수에 대한 호이스팅 작업을 사전에 부여하지 않거나, 그렇지 않더라도 변수나 함수의 선언단계에서는 작동되지만, 해당 변수나 함수에 할당한 값까지 호이스팅이 되지는 않습니다. 즉 변수나 함수의 선언은 런타임 이전에 호이스팅 현상으로 실행되나, 실제 값의 할당이나 작업은 런타임때에 작동 된다는 것입니다.

4-1 식별자 네이밍

식별자 네이밍(Naming) 규칙은 변수명이나 함수명 등의 이름을 지을때 통상적으로 지키도록 권장되는 규칙으로, 복잡하게 보일수도 있으나, 다음과 같은 규칙을 지킨다면 크게 문제가 되지 않습니다.

- 식별자는 첫글자는 기호나 숫자를 제외한 문자로 해야합니다.
- 식별자는 문자, 숫자, 밑줄, 달러 기호($)를 포함할 수 있습니다.
- 변수의 대소문자를 구분합니다. 즉 name과 Name을 다르게 본다는 것이죠.
- 이미 예약되어 있는 키워드(예약어)는 식별자 이름으로 지정할 수 없습니다.
- 식별자의 이름은 저장되는 값이나 목표하고자 하는 작업, 혹은 변수나 함수, 클래스나 객체 등의 개념에 연관있는   의미 있는 이름을 권장합니다.

```
// 유효한 식별자
var myVariable;
function calculateTotal() { /* ... */ }
class Customer { /* ... */ }
let user1;
const _privateVar;
let $specialVar;

// 유효하지 않은 식별자 (예약어 사용)
var if = 10; // 오류: "if"는 예약어
```

특히 변수나 함수, 객체나 클래스의 이름에는 카멜 케이스(Camel Case)를, 생성자 함수나 클래스를 생성할때는 파스칼 케이스(Pascal Case)가 권고됩니다.

```
let korean"F"amouse"P"lace = "Seoul" -> 카멜 케이스 예시(낙타 등처럼 생겼다.)

function "C"ourse () {
  console.log("swimming pool")
}; -> 파스칼 케이스 예시 (첫 머리글이 대문자.)

```

5-1 표현식과 문

표현식(expression)은 그 자체가 값으로 평가 될 수 있는 모든것을 의미하며, 문(statement)란 실질적으로 실행 가능한 프로그램 구성 중의 최소 실행 단위입니다. 이 둘을 구분 짓기 위해서는 값을 반환 하는가, 안하는가에서 가장 크게 갈린다고 볼 수 있습니다. 물론 이 개념을 자세히 알아야 하는지의 여부를 자바스크립트를 공부하는 입장에서 생각해보았을때 크게 신경을 안써도 됩니다. 이 개념들을 자세히 모르더라도 개발에 큰 문제는 없습니다.

```
① let sum = 10; -> 여기서 10은 그 자체로 10이라는 값을 반환하므로 표현식입니다.

② let sum = 10; -> 그와 동시에 이 코드 자체는 10이라는 변수를 sum 변수에 할당하는 실행 프로그램의 최소 단위이므로  이 코드 자체로도 '할당문' 으로 볼 수 있습니다.

```