1-1 함수의 정의

수학에서의 함수는 입력(input)을 받아 출력(output)을 내보내는 일련의 과정입니다. 그리고 자바스크립트에서의 함수란 이러한 수학에서의 함수처럼 일련의 과정을 거쳐 결과값을 반환하거나, 반환 없이 특정 코드를 실행하는 과정이라고 할 수 있습니다.

```
① 함수의 기본 예제1) 매개 변수가 없고 반환값 없이 특정 코드를 실행하는 함수 선언.

let a = 1, b = 2; // 각각의 변수 선언 후

function add(){ //add 함수 선언
  console.log(a + b) //코드 블록 안에 a와 b를 더한 값을 콘솔에 출력하는 코드 작성
}
add() //add 함수 호출

② 함수의 기본 예제2) 매개 변수를 전달하고 반환값 없이 특정 코드를 실행하는 함수 선언.

function add(a,b){ // add 함수에 값을 전달 받은 매개변수 a와 b를 선언
  console.log(a + b) // 다음 작업을 수행
}
add(1,2); //add 함수에 인수로 1과 2를 전달.

③ 함수의 기본 예제3) 매개 변수를 전달하고 그 결과를 반환 받아 출력하기

function add(a,b){ //전달 된 인수를 a와 b 매개변수에 저장
  return a+b; //a와 b를 더한 값을 result에 반환
}
let result = add(1,2); //result 변수에 add 함수를 실행하여 반환된 값을 저장
console.log(result); // result의 값 출력

```

1-2 함수의 구성 요소

함수의 구성은 크게 이름, 매개변수, 실행문, 반환값으로 정의되며 이렇게 구성된 함수를 호출 할 때 사용이 가능한데, 각각의 함수 구성에 대해서 자세히 살펴보겠습니다.

- 이름 : 함수의 기본적인 이름을 정의하며 호출될 때 사용이 됩니다. 이 함수의 이름은 함수 선언문으로 선언되었느냐, 함수 표현식으로 선언되었느냐에 따라 생략 가능하며 이때의 함수를 익명 함수라고 정의합니다.

- 매개변수 : 함수 호출시에 넘겨주는 인자의 값을 저장하는 변수들 입니다. 매개변수는 해당 함수 안에서만 존재하기 때문에 함수에서 선언된 매개변수는 스코프 바깥의 다른 중복되는 변수에 영향을 받지 않습니다. 단 전달되는 인수의 순서대로 매개변수에서 그 값이 저장되며 가령 fucntion add(x,y)로 매개변수가 정해진 함수에 add(1,2)로 인수를 넘겨주었다면 1은 x에, 2는 y에 각각 저장됩니다. 만약 변수를 인수로 넘겨준다면 변수에 저장된 값이 매개변수에 저장되는데, add 함수의 매개변수가 둘인데 넘겨주는 인수는 하나 밖에 없을때 나머지 못받은 매개변수의 값은 undefined가 저장되므로 주의를 할 필요가 있습니다. 
만약 그럴 경우를 대비해 매개변수에 값을 대입하는 것처럼 지정을 해준다면 값을 넘겨받지 못한 경우에는 함수의 매개변수에 기본값을 지정하는 것 또한 가능하고, 인자로 넘겨주는 값을 가지고 있는 변수와 매개변수의 이름이 동일할 필요 없이 매개변수의 이름은 사용자가 자율적으로 지정이 가능합니다.

```
① 함수의 기본적인 예시) 선언한 매개변수와 인자가 동일한 경우
function add(a,b){
  console.log(a+b)
}

add(1,2)

② 함수의 기본적인 예시) 선언한 매개변수와 인자가 동일한 경우
function add(a,b){
  console.log(a+b) // a는 1을 전달 받으나 b는 undefined가 되므로 연산 결과인 NaN이 출력됩니다.
}

add(1)

③ 함수의 기본적인 예시) 선언한 매개변수에 기본값을 설정한 경우

function add(a,b=2){
  console.log(a+b) //b는 기본값이 2므로 인자를 넘겨받지 못했더라도 기본값이 설정되어 연산 결과인 3이 출력됩니다.
}

add(1) // 인자를 하나만 넘겨주더라도

④ 함수의 기본적인 예시) 선언한 매개변수에 비해 인자값이 많은 경우

function add(a,b=2){
  console.log(a+b) //a는 1이, b는 기본값이 설정 되었어도 무시되고 2가, 3은 무시되어 1+2인 3이 출력됩니다.
}

add(1,2,3) // 인자를 세 개를 넘겨줄 경우

```

- 실행문 : 주로 함수의 기능을 정의하는 코드문 입니다. 매개변수를 이용하여 값을 반환하거나, 반환하지 않고 단독으로 실행하는 과정 등이 정의됩니다.

- 반환문 : 실행문의 결과를 반환하는대 사용되며, return 키워드를 이용해 함수 내 결과값이나 특정 값을 반환합니다. 만약 반환문에 키워드인 return만 있고 무엇을 반환할지를 뒤에 작성해주지 않으면 undefined를 반환하며, 반환문이 선언된 이후의 코드문은 무시되고, 또 자바스크립트는 세미콜론 자동 삽입이 활성화 되어있기 때문에 return 키워드에 세미콜론을 붙이지 않고 바로 아래에 반환할 값이나 표현식을 작성하는 것 또한 무시되기 때문에 한 줄에 return 키워드와 반환값을 작성하는 주의가 필요합니다.


1-3 함수 정의의 종류

이러한 함수를 실행하는 이유는 값이 매번 달라질 경우 동일한 작업을 수행하는 한에서 일일이 코드를 작성하는게 아닌, 동일한 작업을 정의하는 함수를 사전에 만들어 놓아 활용하여 코드의 간결성과 작업의 효율성을 확보하고 또한 신뢰성과 가독성을 향상시킬 수 있기 때문입니다. 또한 앞서 살펴본 객체 리터럴과 같이 함수 또한 변수에 할당하는 것 또한 가능합니다.

```
① 함수 리터럴 예시)

let calc = function add(a,b){
  return a+b;
}; // calc 변수에 add 함수 리터럴을 할당. 여기서 add를 지우고 function 키워드만 단독으로 사용하는 것도 가능합니다.

```

- 또한 자바스크립트에서 함수를 정의함에 있어서 다양한 방법으로 선언이 가능하며, 각각의 표현식은 다음과 같습니다.

```
① 함수 선언문) 함수의 이름을 직접적으로 지정합니다. 즉 함수의 이름을 지정하지 않고 function 키워드를 단독으로 사용하는 것은 자바스크립트에서 허용되지 않습니다.

function add(a,b){
  return a+b;
}

② 함수 표현식) 함수 리터럴로 생성한 함수 객체를 변수에 할당합니다. 이때 이름이 지정되어 있지 않고 function 키워드만 있는 상태의 함수를 익명 함수라고 부릅니다. 

let add = function(a,b){
  return a+b;
}

★ 기본 개념에서 살펴볼 수 있는 호이스팅의 개념을 여기서도 접목 가능한데, 함수 선언문은 런타임 이전에 호이스팅에 의해 함수 객체로서 미리 선언이 되고, 함수 표현식은 값의 대입이 런타임 시점에 이뤄지는 것과 같이 함수 리터럴도 런타임이 실행되는 시점에 평가될 때 함수 객체가 선언되는대에 그 차이점을 둘 수 있습니다.

③ function 생성자 함수) 자바스크립트에서 기본적으로 제공하는 빌트인 함수인 Function 생성자 함수에 매개변수 목록과 함수 몸체(스코프 영역)를 문자열로 전달하면서 new 연산자와 함께 호출하여 함수 객체를 반환 받는 방법입니다. 이때 new 키워드는 생략이 가능합니다. 일반적으로 잘 사용이 되지 않기 때문에 개념만 알아두셔도 됩니다.

let add = new Function('a', 'b', 'return a+b');

④ 화살표 함수) ES6에서 도입된 함수 정의 방식으로서 function 키워드 대신 화살표(=>)를 사용해 보다 간략하게 함수를 선언할 수 있습니다.

let add = (a,b) => a+b;

```

1-4 다양한 함수 형태

자바스크립트에서 함수는 정의에 있어서도 여러 종류가 있지만 그 외에 특별한 함수들 또한 존재합니다.

- 즉시 실행 함수(immediately invoked Function Expression)
런타임때에 함수 정의와 동시에 즉시 호출되는 함수이며 익명 함수를 사용하는 것이 일반적입니다. 이 함수는 함수 리터럴로 표현되며 실행이 된 후에는 호출이 불가능 합니다. 하지만 함수 표현식을 사용시 인자를 넘겨 받는 작업 또한 가능합니다.

```

① 일반적인 즉시 실행 함수 선언 방법)

function(){
  let a = 1, b = 2;
  console.log(a+b);
}(); // 함수의 구분자 바로 앞에 비어있는 쌍괄호를 넣어 이 함수가 즉시 실행 함수임을 나타냅니다.

② 괄호로 감싸 생성하는 함수 리터럴 선언)

(function(){
  let a = 1, b = 2;
  console.log(a+b);
}()); // 함수 전체를 쌍괄호로 감쌉니다.

③ 즉시 실행 함수의 값 반환)

let add = (function(){
  let a = 1, b = 2;
  return a+b;
}()); // 함수 표현식 방법으로 add 변수 안의 함수를 선언과 함께 즉시 실행하여 반환값을 add에 저장합니다.

④ 즉시 실행 함수에 인자를 전달하는 법)

let add = (function(a,b){ // 매개변수를 입력합니다.
  return a+b;
}(3,5)); // 구분자 앞 쌍괄호에 전달할 인자를 입력하면 그 값을 전달 받아 함수 실행 후 값을 add에 반환합니다.

```

- 재귀 함수(recursive call)
함수가 자기 자신을 호출하는 함수이며, 함수의 이름을 활용합니다. 재귀 함수의 경우 무한히 자신을 반복하는 함수의 구현 특성상 조건문을 걸어 특정 조건에서 break를 걸거나 return문을 새로 주어 빠져나가는 코드부를 구현해야 합니다. 하지만 이러한 재귀 함수는 수학적 문제를 해결하는 작업에 주로 사용되며, 일반적인 프로그래밍 상황에서는 특별한 상황을 제외하고는 for문이나 while문으로 대체 되기 때문에 사용법만 알고 있으면 충분합니다. 

```

① for 반복문을 구현한 재귀 함수)

function countdown(n){
  if(n < 0) return; // 만약 전달 받은 매개변수가 0보다 작을 경우 return으로 함수 종료
  console.log(n) // if 조건문이  거짓일 경우 아래의 매개변수의 현재값을 콘솔에 출력 하고
  countdown(n - 1); // 매개변수에서 -1한 값을 다시 countdown 함수를 호출하여 전달.
}

countdown(10); //카운트다운 함수 호출

② 팩토리얼을 구현한 재귀 함수)

function fatorial(n){ //인자를 받아서
  if (n <= 1 )return 1; // 매개변수의 값이 1보다 작은 0 이하의 음수라면 1을 반환하고
  return n * fatorial(n - 1); // 조건에 맞지 않아 실행되는 다음 return 문, n이 1 이상일 때는 매개변수에 매개변수 - 1 연산처리 한 결과값을 곱해 반환합니다.
}

for(let i = 0 ; i <= 5 ; i++){ // for문을 다섯번 돌려
  console.log(fatorial(i)); //fatorial i값을 전달.
}
// 만약 fatorial 함수에 전달할 i값이 5라면 fatorial은 5를 받은 후 두번째 return문에서 5*(n-1)문으로 들어가는데, 이때 fatorial 함수가 발동되어 4가 전달되고 결과적으로 5*4*3*2*1의 값인 120이 출력됩니다.
```
※ - 중첩 함수 (클로저 학습 이후 설명 예정) ※

- 콜백 함수(callback function)
인자로 넘겨줄 때 포함 되는 함수를 의미하며 이때 콜백 함수를 인자로 넘겨 받는 함수를 고차 함수(higher-order function)이라고 부릅니다. 이 콜백 함수는 앞서 소개한 다른 함수의 종류와는 다르게 매우 중요한 개념 중 하나이므로 특히 사용법을 익히는 것이 중요합니다. 

```
function processArray(arr, callback) { // 배열과 콜백함수를 인자로 전달 받아
  for (let i = 0; i < arr.length; i++) { // 배열의 길이만큼 반복하는 동안
    callback(arr[i]); //콜백함수를 호출하여 배열의 i번째의 값을 인자로 또 전달하면 콜백 함수 안에서 인덱스의 i번째 값을 출력합니다.
  }
}

function logItem(item) { // item을 출력하는 함수 정의
  console.log(item);
}

const myArray = [1, 2, 3, 4, 5]; // 다섯개의 값이 들어있는 변수 myArray를 선언 및 초기화

processArray(myArray, logItem); // 배열 변수와 item 콘솔 출력 함수를 인자로 전달

```

- 순수 함수(Pure Function)와 비순수 함수 (Impure Function)
순수 함수는 어떠한 외부 상태에도 달라지지 않으며 그 반대로 외부의 상태를 변경하지 않고, 부수 효과가 없는 함수를 의미하고, 비순수 함수는 그의 반대 되는 개념의 함수입니다. 즉 함수가 외부의 어떠한 변수나 코드에 직접적으로 영향을 주지 않을 경우 순수 함수이고, 그 반대로 영향을 줄 경우 비순수 함수가 된다는 개념 정도로 이해하시면 됩니다.

```

① 순수 함수 예시) 인자로 넘겨 받은 값에게만 의존해 값을 생성하고 반환합니다.

let count = 0; //

function increase(n){
  return ++n; // 동일한 입력에 대한 동일한 결과를 반환합니다.
}

count = increase(count); // count 변수에 increase 함수를 호출하여 반환된 값 0을 count에 재할당.
console.log(count); // 반환 받은 count의 값 1 출력

② 비순수 함수 예시) 외부 상태를 변경하는 부수효과를 가집니다.

let count = 0; // 초기 카운트의 값은 0

function increase(){
  return ++count; // 외부에 있는 count 값을 직접적으로 변경
}

increase(); // count 함수를 증가 시키는 함수 호출
console.log(count) // 함수에 의해 변경 된 값 1 출력

```

1-5 ES6 이후의 함수

ES6 이전까지 자바스크립트의 함수는 다양한 목적으로 사용되어 왔습니다. 일반적인 함수나 생성자 함수, 메서드 등으로 사용이 되어왔는데요. 문제는 객체에 바인딩 된 메서드가 함수인 동시에 constructor이기도 하고, 콜백 함수 또한 constructor이기 때문에 개발자의 의도대로 작성된 함수들이 의도치 않는 코드 흐름을 불러올수도 있고, 메모리의 누수를 불러올 수도 있기에 ES6 에서는 함수를 사용 목적에 따라 세 가지 종류로 명확히 구분했다고 합니다. 

1. 메서드) ES6 전까지 메서드는 객체 내부의 함수를 의미했으나, ES6 부터는 메서드 축약 표현(funtion 키워드를 생략)으로 정의된 함수만을 의미하게 되었습니다. 그래서 메서드는 생성자 함수로서 호출될 수 없으며, 프로토타입 프로퍼티가 없고, 프로토타입도 생성하지 못합니다. 그러나 super 키워드를 통해 상속 받은 객체의 프로퍼티나 메서드를 참조할 수 있으며, 이를 통해 메서드 본연의 역할을 확보할 수 있는 것이죠.

```

const iAm = {
  name : 'Re_Go',
  age : 30,
  introduce(){ // 메서드 축약 표현으로 function 키워드를 생략한 함수는 해당 객체의 메서드로 취급됩니다.
    console.log(`안녕? 나는 ${this.name} 이고 나이는 ${this.age}살 이야!`)
  },
  getMarriage: function(marriage){ // function 키워드를 사용하는 일반적인 익명 함수 표현식을 통한 함수 프로퍼티 추가는 일반 함수로 취급됩니다.
      this.introduce();
      if(marriage === false) console.log(`근데 i am 솔로에요.... 이이 쉿펄!`);
      else console.log(`하... 결혼은 지옥이야...`);
  }
}

iAm.getMarriage(false); // 메서드 호출

```

2) 화살표 함수


