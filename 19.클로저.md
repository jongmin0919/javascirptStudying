1-1 클로저란?

클로저는 ECMAScript 사양에 등장하지 않으며, 고유의 개념도 아닙니다. 그러나 MDN에서는 클로저에 대해 "함수와 그 함수가 선언된 렉시컬 환경과의 조합" 이라고 설명하고 있습니다. 즉 앞서 살펴본 실행 컨텍스트에서 해당 함수가 정의 된 시점에서는 해당 함수의 렉시컬 환경의 구성 요소중 하나인 환경 레코드의 [[Enviroment]] 슬롯에 자신이 정의 된 환경인 상위 스코프의 참조를 저장합니다. 그리고 여기서 정리되는 클로저의 개념은 외부 함수보다 중첩 함수가 더 오래 유지되는 경우, 즉 스택 상에 중첩 함수가 최상단에 위치할 경우 렉시컬 환경 검색이 가능한데 이러한 개념을 바로 클로저라고 부르는 것이죠.

앞서 실행 컨텍스트에서도 살펴본 바와 같이 스택 상에서 특정 컨텍스트가 제거되어도 그 컨텍스트의 렉시컬 환경을 참조하는 다른 객체가 있다면 가비지 컬렉터가 그 렉시컬 환경을 제거하지 않기 때문에 중첩 함수의 환경 레코드에서 [[Environement]] 슬롯이 해당 상위 스코프(함수의 렉시컬 환경)을 참조하고 있는 한 해당 스코프에서 요소들을 검색할 수 있는 개념이 바로 클로저라고 정리할 수 있습니다.

그러나 중첩 함수가 상위 스코프(함수)의 어떠한 식별자도 참조하지 않거나, 컨세트스 스택 상 중첩 함수가 먼저 종료되어 외부 함수가 참조되지 않는 경우 클로저라고 보지 않기 때문에, 이러한 클로저는 중첩 함수가 상위 스코프의 식별자를 참조하고 있고, 중첩 함수가 외부 함수보다 더 오래 유지되는 경우에 한정하는 것을 일반적으로 합니다.

1-2 클로저의 활용 예시

1. 변수의 상태가 의도치 않게 변경되지 않도록 안전하게 은닉하고, 특정 함수에게만 상태 변경을 허용하기 위해서 사용합니다.

```

① 특정 변수에 대한 함수 우선권 제공) 해당 num 변수는 increase 함수 뿐만 아니라 다른 메서드나 함수에서도 접근이 가능한 전역 변수이기 때문에 increase 함수로만 값을 참조하고 변경되게 하도록 전역 변수 num을 increase 메서드의 지역 변수 num으로 선언하면 상태가 보장됩니다.

1) let num = 0; // 전역 변수 num의 초기값을 0으로 할당시 모든 메서드에서 접근이 가능합니다.

const increase = function(){
2)  let num = 0; // num을 increase 메서드의 지역 변수로 선언하면 increase 함수에서만 단독 사용이 가능하므로 상태 유지가 가능합니다.
    return ++num; //num을 증가시키는 연산 수행

}

console.log(increase()); // num이 전역 변수일 경우는 1이고, 지역 변수일 경우 1입니다.
console.log(increase()); // num이 전역 변수일 경우는 2이고, 지역 변수일 경우 1입니다.
console.log(increase()); // num이 전역 변수일 경우는 3이고, 지역 변수일 경우 1입니다.

② 이전 상태 유지를 위한 즉시 실햄 함수 적용) 위의 코드에서 함수가 실행될 때마다 함수에서만 num 접근이 가능하나, 사용자가 의도한 대로 num의 값이 증가되지 않고 매번 호출될 때 마다 num의 값이 0으로 초기화가 됩니다. 그러므로 

1) let num = 0; // 전역 변수 num의 초기값을 0으로 할당시 모든 메서드에서 접근이 가능합니다.

const increase = function(){
2)  let num = 0; // num을 increase 메서드의 지역 변수로 선언하면 increase 함수에서만 단독 사용이 가능하므로 상태 유지가 가능합니다.
    return ++num; //num을 증가시키는 연산 수행

}

const increase = (function(){ //increase 변수에 즉시 실행 함수 코드문을 할당하는데
    let num = 0; // 이 부분은 즉시 실행 함수 안에서 선언된 지역 변수이기에 한 번만 실행되고 소멸됩니다.
    
    return function(){ // 하지만 이 부분에서는 즉시 실행 함수 안에 포함 되어 있더라도 상위 스코프(즉시 실행 함수)의 num 변수를 참조하고 있기 때문에 이 익명 함수는 스택에서 소멸되지 않고 increase 변수에 할당되게 됩니다.
        return ++num;
    };
})();

console.log(increase()); // 이제 increase 함수를 호출시 익명 함수가 호출되어 num의 값이 1 증가 됩니다.
console.log(increase()); // 마찬가지로 num은 2로 증가됩니다.
console.log(increase()); // 최종적으로 num은 3으로 증가됩니다.

③ 즉시 실행 함수를 이용하여 값을 누적 감소시키는 예제)

```

const Counter = (function(){
    let num = 0;

    function Counter(){ // 생성자 함수 Counter를 생성합니다.
        // Counter 메서드에는 num을 참조하는 값이 없으나, 프로토타입 메서드인 increase와 decrease에서 num을 클로저로 포획하고 있기 때문에 Counter 객체(this) 에서 num 변수를 가지고 있지 않더라도 num 변수를 유지시키고 사용할 수 있습니다.
    }

    Counter.prototype.increase = function(){ // Counter 생성자 함수의 프로토타입 메서드인 increase를 선언하여 num의 값을 누적 증가시켜 반환하는 메서드를 구현합니다. 이때 increase 메서드는 num 변수를 클로저로 포획하고 있습니다.
        return num++;
    };
    Counter.prototype.decrease = function(){ // decrease 메서드도 increase 메서드 설명과 동일하게 num 변수를 클로저로 포획하여 사용하고 있습니다.
        return num > 0 ? --num : 0;
    };

    return Counter; // 생성자를 반환합니다. 이때 반환문은 생략이 가능합니다.
});

const counter = new Counter(); // Counter 객체 생성

console.log(counter.increase()); // 객체의 increase 메서드 호출시 1 반환
console.log(counter.increase()); // 마찬가지로 2 반환
console.log(counter.decrease()); // 객체의 decrease 메서드 호출시 2에서 1로 감소시키고 반환
console.log(counter.decrease()); // 마찬가지로 0 반환

