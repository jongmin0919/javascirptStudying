1-1 실행 컨텍스트란?

실행 컨텍스트는 자바스크립트의 동작 원리를 담고 있는 핵심 개념입니다. 이 원리를 이해하면, 스코프를 기반으로하는 자바스크립트의 식별자 및 식별자에 바인딩 되는 값을 관리하는 방법, 호이스팅의 발생 이유등 전반적인 자바스크립트의 동작 원리를 알 수 있기 때문입니다. 그리고 이러한 실행컨텍스트는 소스코드의 타입에 따라 생성되는 과정 및 관리 내용이 달라지게 됩니다.

소스코드의 타입은 크게 전역, 함수, 모듈, eval 코드로 나누며, 이들 중 eval 코드를 제외한 나머지 코드에 대해서는 함수 및 클래스 등 내부 코드는 포함하지 않습니다.

1. 전역 코드 : 전역 변수 관리를 위해 최상위 스코프인 전역 스코프를 생성하고, 전역 변수 및 전역 함수를 전역 객체의 프로퍼티와 메서드로 바인딩하고 참조하기 위해 전역 객체와 연결할 때 이 전역 코드가 평가된 후 전역 실행 컨텍스트가 생성됩니다.

2. 함수 코드 : 지역 스코프를 생성하고 지역 변수, 매개변수, arguments 객체를 관리합니다. 생성한 지역 스코프를 전역 스코프에서 시작하는 스코프 체인의 일원으로 연결하며 이 함수 코드가 평가된 후 함수 실행 컨텍스트가 생성됩니다.

3. 모듈 코드 : 각각의 독립적인 모듈 스코프를 생성하며, 모듈 코드가 평가된 후 모듈 실행 컨텍스트가 생성됩니다.

4. eval 코드 : strict mode에서 자신만의 독자적인 스코프를 생성하며, eval 코드가 평가된 후 eval 실행 컨텍스트가 생성됩니다.

1-2 소스 코드의 평가와 실행

모든 소스코드는 평가 -> 실행 단계를 거칩니다. 평가 과정에서는 선언문만 먼저 실행하여 생성된 변수나 함수 식별자를 키로 하여 실행 컨텍스트가 관리하는 렉시컬 환경과 환경 레코드(렉시컬 환경은 실행할 스코프 범위 안에 있는 변수와 함수를 프로퍼티로 저장하는 객체를 의미하며, 환경 레코드는 렉시컬 환경을 구성하는 구성 요소 중 모든 로컬 변수들을 프로퍼티로 갖는 객체를 의미합니다.)에 등록합니다. 이를 런타임 전 과정이라고 보시면 됩니다.

이러한 소스평가 과정에서는 선언문 등의 등록이 이루어지며, 소스평가 과정이 끝나면 선언문을 제외한 소스코드가 순차적으로 실행됩니다. 그리고 이 과정을 우리는 런타임이라고 부르죠. 이때 소스코드 실행에 필요한 변수나 함수의 참조 정보를 실행 컨텍스트가 관리하는 렉시컬 환경에서 검색 및 취득한 후 이를 바탕으로 실행된 소스코드의 결과를 실행 컨텍스트가 관리하는 스코프에 등록합니다. 이 과정을 요약하자면 다음과 같습니다.

- 런타임 이전 선언문의 정보를 렉시컬 환경에 등록 
- 런타임 동안 변수나 함수 실행에 필요한 참조 정보를 렉시컬 환경에서 검색 
- 검색된 정보를 바탕으로 변수 및 함수를 실행한 결과를 실행 컨텍스트가 관리하는 스코프에 등록

실행 컨텍스트는 식별자를 등록하고 관리하는 스코프와 코드 실행 순서(실행 컨텍스트 스택) 관리를 구현한 내부 메커니즘으로, 모든 코드는 실행 컨텍스트를 통해 실행되고 관리된다고 정의할 수 있는 것이죠.

```

① 전역 변수에 대한 소스코드의 평가 및 실행 예시) 전역 변수 및 함수의 평가 과정이 끝난 후 전역 객체의 프로퍼티와 메서드로 바인딩 되는 평가 단계와, 순차적으로 실행될때에는 변수에 값이 할당되고, 함수가 호출되면 순차 과정을 일시 중단하고 호출된 함수 내부로 진입하여 먼저 실행하는 과정을 거칩니다.

var x = 10; // var x를 런타임 전에 먼저 실행 후 undefined로 초기화 하고, 런타임에는 x가 선언된 변수, 즉 렉시컬 환경에 등록 된 변수인지를 확인 후 리터럴을 할당합니다.

② 함수 선언문에 대한 소스코드의 평가 및 실행 예시) 런타임 이전에는 함수 내의 선언된 선언문이 평가되고, 런타임 동안에는 해당 함수가 호출될 경우 다음 처리 순서에서 정지하고 해당 함수 실행을 실시한 후에, 해당 함수 실행이 종료되면 다시 정지되었던 해당 스코프로 이동 후 순차적으로 코드를 처리합니다.

function letsAdd(a){ // 함수가 호출되면 런타임 이전에 함수 선언문의 매개변수 및
    const b = 20; // 지역 변수 등이 등록되고
    const c = 30;
    this.a = a; // this의 바인딩도 결정됩니다.
    console.log(a+b+c); // 선언문을 제외한 나머지 코드는 런타임 동안, 즉 함수 내에서의 평가가 이루어진 후에 함수 내에 변수들에 순차적으로 리터럴이 할당 되면서 해당 코드의 차례에 도달할 때 해당 스코프 체인(프로토타입 체인 검색)을 검색 후 실행됩니다.
};

letsAdd(10); // 함수 호출시 아래 단계로 이동하는 것이 아니라 해당 함수로 이동 후 처리 과정이 끝나면 다시 여기서 다음 아래 단계(순차적으로)로 처리 됩니다.

③ 중첩 함수에 대한 소스코드의 평가 및 실행 예시) 중첩 함수의 경우, 각 함수 당 가지는 함수 실행 컨텍스트를 가지고 있으며, 스택 방식으로 관리가 되므로 실행 컨텍스트의 원리를 아는대에 중요한 역할을 합니다.

const x = 1; // 런타임 이전에는 const x로 등록 후 런타임 동안 x에 1을 할당합니다.

function add(){ // 런타임 이전에 전역 실행 컨텍스트에 등록되며, 런타임 동안 add가 호출되면 해당 함수를 컨텍스트 스택에 적재합니다.
    const y = 2; // 해당 지역변수는 add 함수가 호출된 시점에 평가되고 런타임 동안에 값 할당이 이루어지며
    console.log(x+y) // 해당 메서드가 실행되어 실행을 한 후 중첩 함수 bar를 함수 실행 컨텍스트에 등록합니다.
    function sub (){ // 이후 해당 함수 호출시 내부의 지역 변수가 함수 컨텍스트에 등록되고, 런타임 동안 값을 할당하며 마찬가지로 메서드도 실행 후 종료합니다.
        const z = 3;
        console.log(z-y-x);
    }
    sub();
}
add();

★ 중첩 함수에 대한 다음 실행 순서는 다음과 같습니다.

- 런타임 전에 전역 변수 x와 및 함수 선언문(전역 함수)add를 전역 실행 컨텍스트에 등록
- 이후 전역 코드가 실행되고 변수 x에 값을 할당 후 함수 add를 호출
- 함수 add가 호출되면 함수 실행 컨텍스트에 지역 변수 y와 중첩 함수 sub을 등록 후 런타임 동안 y에 값을 할당 후 console.log 수행 후 sub 함수 호출
- 함수 sub이 호출되면 마찬가지로 함수 실행 컨텍스트에 지역 변수 z를 등록 후 런타임 동안 z에 값을 할당하고 console.log를 수행한 후 sub 함수 종료
- 마찬가지로 add 함수 복귀 후 더이상 실행할 코드문이 없을 경우 종료 후 최종적으로 전역 코드 복귀 후 마찬가지로 실행할 코드가 남아있을 경우 실행하고, 없을 경우 종료.

```