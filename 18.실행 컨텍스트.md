1-1 실행 컨텍스트란?

실행 컨텍스트는 자바스크립트의 동작 원리를 담고 있는 핵심 개념입니다. 이 원리를 이해하면, 스코프를 기반으로하는 자바스크립트의 식별자 및 식별자에 바인딩 되는 값을 관리하는 방법, 호이스팅의 발생 이유등 전반적인 자바스크립트의 동작 원리를 알 수 있기 때문입니다. 그리고 이러한 실행컨텍스트는 소스코드의 타입에 따라 생성되는 과정 및 관리 내용이 달라지게 됩니다.

소스코드의 타입은 크게 전역, 함수, 모듈, eval 코드로 나누며, 이들 중 eval 코드를 제외한 나머지 코드에 대해서는 함수 및 클래스 등 내부 코드는 포함하지 않습니다.

1. 전역 코드 : 전역 변수 관리를 위해 최상위 스코프인 전역 스코프를 생성하고, 전역 변수 및 전역 함수를 전역 객체의 프로퍼티와 메서드로 바인딩하고 참조하기 위해 전역 객체와 연결할 때 이 전역 코드가 평가된 후 전역 실행 컨텍스트가 생성됩니다.

2. 함수 코드 : 지역 스코프를 생성하고 지역 변수, 매개변수, arguments 객체를 관리합니다. 생성한 지역 스코프를 전역 스코프에서 시작하는 스코프 체인의 일원으로 연결하며 이 함수 코드가 평가된 후 함수 실행 컨텍스트가 생성됩니다.

3. 모듈 코드 : 각각의 독립적인 모듈 스코프를 생성하며, 모듈 코드가 평가된 후 모듈 실행 컨텍스트가 생성됩니다.

4. eval 코드 : strict mode에서 자신만의 독자적인 스코프를 생성하며, eval 코드가 평가된 후 eval 실행 컨텍스트가 생성됩니다.

1-2 소스 코드의 평가와 실행

모든 소스코드는 평가 -> 실행 단계를 거칩니다. 평가 과정에서는 선언문만 먼저 실행하여 생성된 변수나 함수 식별자를 키로 하여 실행 컨텍스트가 관리하는 렉시컬 환경과 환경 레코드(렉시컬 환경은 실행할 스코프 범위 안에 있는 변수와 함수를 프로퍼티로 저장하는 객체를 의미하며, 환경 레코드는 렉시컬 환경을 구성하는 구성 요소 중 모든 로컬 변수들을 프로퍼티로 갖는 객체를 의미합니다.)에 등록합니다. 이를 런타임 전 과정이라고 보시면 됩니다.

이러한 소스평가 과정에서는 선언문 등의 등록이 이루어지며, 소스평가 과정이 끝나면 선언문을 제외한 소스코드가 순차적으로 실행됩니다. 그리고 이 과정을 우리는 런타임이라고 부르죠. 이때 소스코드 실행에 필요한 변수나 함수의 참조 정보를 실행 컨텍스트가 관리하는 렉시컬 환경에서 검색 및 취득한 후 이를 바탕으로 실행된 소스코드의 결과를 실행 컨텍스트가 관리하는 스코프에 등록합니다. 이 과정을 요약하자면 다음과 같습니다.

- 런타임 이전 선언문의 정보를 렉시컬 환경에 등록 
- 런타임 동안 변수나 함수 실행에 필요한 참조 정보를 렉시컬 환경에서 검색 
- 검색된 정보를 바탕으로 변수 및 함수를 실행한 결과를 실행 컨텍스트가 관리하는 스코프에 등록

즉 실행 컨텍스트는 렉시컬 환경과 식별자를 등록하고 관리하는 스코프(렉시컬 환경)와 코드 실행 순서(실행 컨텍스트 스택) 관리를 메인으로 전체 코드를 관리하고 실행시키도록 구현된 내부 메커니즘으로 이라고 정리할 수 있습니다.


1-2 실행 컨텍스트 스택이란?

실행 컨텍스트 스택이란 실행 컨텍스트에서 소스코드의 타입을 분류할 때 각각의 코드를 평가 후 해당하는 실행 컨텍스트를 생성하여 흐름에 따라 실행 컨텍스트 스택에 각각의 컨텍스트들을 추가(push) 하거나 제거(pop) 함으로서 스택 자료구조 방식으로 전체 코드의 실행 흐름을 제어하는 프로세스이며, 스택 방식인 LIFO(Last-in-First-out) 방식으로 해당 프로세스가 처리됩니다.

이러한 프로세스의 적재 특성으로 인해 현재 스택에서 최상단에 위치한 컨텍스트는 현재 실행 중인 실행 컨텍스트라고도 불립니다.

```

① 전역 변수에 대한 소스코드의 평가 및 실행 예시) 전역 변수 및 함수의 평가 과정이 끝난 후 전역 객체의 프로퍼티와 메서드로 바인딩 되는 평가 단계와, 순차적으로 실행될때에는 변수에 값이 할당되고, 함수가 호출되면 순차 과정을 일시 중단하고 호출된 함수 내부로 진입하여 먼저 실행하는 과정을 거칩니다.

var x = 10; // var x를 런타임 전에 먼저 실행 후 undefined로 초기화 하고, 런타임에는 x가 선언된 변수, 즉 렉시컬 환경에 등록 된 변수인지를 확인 후 리터럴을 할당합니다.

② 함수 선언문에 대한 소스코드의 평가 및 실행 예시) 런타임 이전에는 함수 내의 선언된 선언문이 평가되고, 런타임 동안에는 해당 함수가 호출될 경우 다음 처리 순서에서 정지하고 해당 함수 실행을 실시한 후에, 해당 함수 실행이 종료되면 다시 정지되었던 해당 스코프로 이동 후 순차적으로 코드를 처리합니다.

function letsAdd(a){ // 함수가 호출되면 런타임 이전에 함수 선언문의 매개변수 및
    const b = 20; // 지역 변수 등이 등록되고
    const c = 30;
    this.a = a; // this의 바인딩도 결정됩니다.
    console.log(a+b+c); // 선언문을 제외한 나머지 코드는 런타임 동안, 즉 함수 내에서의 평가가 이루어진 후에 함수 내에 변수들에 순차적으로 리터럴이 할당 되면서 해당 코드의 차례에 도달할 때 해당 스코프 체인(프로토타입 체인 검색)을 검색 후 실행됩니다.
};

letsAdd(10); // 함수 호출시 아래 단계로 이동하는 것이 아니라 해당 함수로 이동 후 처리 과정이 끝나면 다시 여기서 다음 아래 단계(순차적으로)로 처리 됩니다.

③ 중첩 함수 사례로 알아보는 자세한 컨텍스트 스택 절차 및 소스코드의 평가 및 실행 예시) 중첩 함수의 경우, 각 함수 당 가지는 함수 실행 컨텍스트를 가지고 있으며, 스택 방식으로 관리가 되므로 실행 컨텍스트의 원리를 아는대에 중요한 역할을 합니다.

const x = 1; // 런타임 이전에는 const x로 등록 후 런타임 동안 x에 1을 할당합니다.

function add(){ // 런타임 이전에 전역 실행 컨텍스트에 등록되며, 런타임 동안 add가 호출되면 해당 함수를 실행 컨텍스트 스택에 적재합니다.
    const y = 2; // 해당 지역변수는 add 함수가 호출된 시점에 평가되고 런타임 동안에 값 할당이 이루어지며
    console.log(x+y) // 해당 메서드가 실행되어 실행을 한 후 중첩 함수 bar를 함수 실행 컨텍스트에 등록합니다.
    function sub (){ // 이후 해당 함수 호출시 내부의 지역 변수가 함수 컨텍스트에 등록되고, 런타임 동안 값을 할당하고 마찬가지로 메서드도 실행 후 종료합니다.
        const z = 3;
        console.log(z-y-x);
    }
    sub(); // sub 함수가 종료되면 실행 컨텍스트 스택에서 sub 함수를 제거(pop) 합니다.
}
add(); // 마찬가지로 add 함수가 종료되면 실행 컨텍스트 스택에서 add 함수를 제거(pop) 합니다.

★ 중첩 함수에 대한 다음 실행 컨텍스트 스택 순서는 다음과 같습니다.

- 런타임 전에 전역 변수 x와 및 함수 선언문(전역 함수)add를 전역 실행 컨텍스트에 등록
- 이후 전역 코드가 실행되어 전역 컨텍스트가 실행 컨텍스트 스택에 적재되어 순차적으로 변수 x에 값을 할당 후 함수 add를 호출합니다.
- 함수 add가 호출되면 함수 실행 컨텍스트에 지역 변수 y와 중첩 함수 sub가 등록 되고, 마찬가지로 해당 컨텍스트가 실행 컨테스트 스택에 적재된 후 런타임 동안 y에 값을 할당 후 console.log 수행 후 sub 함수를 호출합니다.
- 함수 sub이 호출되면 마찬가지로 함수 실행 컨텍스트에 지역 변수 z를 등록 후 실행 컨텍스트 스택에 sub 함수 컨텍스트가 적재된 후 런타임 동안 z에 값을 할당하고 console.log를 수행하고 최종적으로 sub 함수를 종료하는데, 이때 실행 컨텍스트 스택에 있던 해당 함수 컨텍스트를 제거(pop) 합니다.
- 마찬가지로 add 함수 복귀 후 더이상 실행할 코드문이 없을 경우 실행 컨텍스트 스택에서 제거하여 종료 후 최종적으로 전역 코드 복귀 후 마찬가지로 실행할 코드가 남아있을 경우 실행하고, 없을 경우 최종적으로 해당 전역 컨텍스트를 실행 컨텍스트 스택에서 제거하는 것으로 전체 코드문이 종료됩니다.

```

1-3 렉시컬 환경이란?

렉시컬 환경은 실행 컨택스트에서 키와 값을 갖는 객체 형태의 각각의 스코프를 생성하여 식별자를 키로 등록하고, 식별자에 바인딩 된 값을 관리하며 상위 스코프에 대한 참조를 스코프 체인으로 기록하는 자료구조로서 실행 컨텍스트 스택과 함께 실행 컨텍스트를 구성하는 컴포넌트 입니다. 

이러한 렉시컬 환경은 크게 환경 레코드(스코프에 포함된 식별자를 등록하고 해당 식별자의 바인딩 된 값을 관리하는 곳으로 전역 스코프, 전역 빌트인 , 메서드 등 객체등 검색에 필요한 정보를 제공)와 외부 렉시컬 환경에 대한 참조(상위 스코프를 의미하며 해당 실행 컨텍스트를 생성한 소스코드를 포함한 상위 코드의 렉시컬을 의미합니다. 이 참조를 통해 단방량 링크드 리스트인 스코프 체인을 구현합니다.) 두 가지 컴포넌트로 구성됩니다.

1-4 실행 컨텍스트의 생성과 식별자 검색 과정 

실행 컨텍스트가 동작되기 시작하면 우선적으로 전역 코드가 평가되기 전 빌트인 전역 프로퍼티와 함수, 표준 빌트인 객체가 추가된 전역 객체가 생성되며, 동작 환경에 따라 클라이언트 사이트의 Web API, 호스트 객체를 포함하기도 합니다. 그 다음으로 해당 소스코드가 로드되면 자바스크립트 엔진이 전역 코드를 평가 하는데, 평가 순서는 다음과 같습니다.

```
① 전역 객체에 대한 실행 컨텍스트 프로세스)

1. 전역 실행 컨텍스트 생성 후 실행 컨텍스트 스택에 적재 (최상위는 전역 실행 컨텍스트)
2. 전역 렉시컬 환경을 생성하고 해당 전역 실행 컨텍스트에 바인딩
3. 전역 렉시컬 환경을 구성하는 요소중 환경 레코드를 생성합니다. 이때 환경 레코드도 객체 환경 레코드와 선언적 환경 레코드로 구성되는데, 
  - 객체 환경 레코드에는 var 키워드를 포함한 전역 요소들과 관련된 모든 정보들을 제공하며 전역 객체가 생성될 때 BindingObject 객체와 연결되며, 이 객체를 통해 모든 전역 요소들은 전역 객체의 프로퍼티와 메서드가 됩니다. 즉 이 BindingObject를 통해 런타임 이전인 평가 단계에서도 미리 서언과 동시에 변수에는 undefined가 할당되고, 함수도 사용할 수 있는 호이스팅 현상이 만들어지는 것이죠.
  - 그리고 선언적 환경 레코드에는 객체 환경 레코드를 제외한 let, const와 같은 정보들을 관리하고 제공하며 전역 객체의 프로퍼티로서 존재하는 것이 아니라 별도로 구성되는데, 전역 객체의 프로퍼티가 되지 않기 때문에 참조 또한 불가능하며, 이에 따라 객체 환경 레코드의 요소들과는 달리 선언 단계와 초기화 단계가 분리되어 진행됩니다. 다시 말해 스코프 체인 상 존재는 하지만 초기화가 되어있지 않아 런타임 흐름상 변수 선언문에 도달하기 전까지 미리 값을 활용할 수 없는 현상인 일시적 사각지대, TDZ(Temporal Dead Zone)이 유지되는 것이죠. 결과적으로 객체 환경 레코드와 선언적 환경 레코드의 차이는 BindingObject 객체에 의해 해당 요소들이 전역 객체나 메서드로 바인딩 되냐, 그렇지 않느냐에 대한 차이라고 보시면 됩니다. 
4. 전역 환경 레코드의 [[GlobalThisValue]] 내부 슬롯에 전역 객체를 가리키는 this 키워드가 바인딩 됩니다. 그래서 this를 호출하면 전역 환경 레코드의 해당 슬롯에 바인딩 되어있는 전역 객체가 호출되는 것이죠.
5. 전역 렉시컬 환경을 구성하는 요소 중 하나인 외부 렉시컬 환경 참조를 생성하며, 이 참조는 현재 평가 중인 소스코드를 포함하는 외부 소스코드의 렉시컬 환경인 상위 스코프를 결정하는 영역을 의미합니다. 만약 전역 렉시컬 환경에서 외부 렉시컬 환경에 대한 참조를 결정하려 할때, 해당 렉시컬 환경은 스코프 체인상 최상단, 즉 종점에 존재하기 때문에 null의 값을 가집니다. 
6. 위의 작업들이 순차적으로 이루어지면 자바스크립트 엔진은 전역 코드를 순차적으로 실행시키며 식별자가 미리 등록되어 있는지를 환경 레코드에서 검색 및 확인하는 식별자 결정 작업을 실행하는데, 이때 식별자를 검색할 수 없는 경우 외부 렉시컬 참조인 상위 스코프에서 해당 식별자를 참조합니다. 이때의 상위 스코프는 현재 존재하지 않으므로 만약 존재하지 않는 식별자를 검색할 경우 서칭에 실패하게 됩니다.

② 함수 객체에 대한 실행 컨텍스트 프로세스)

1. 함수 실행 컨텍스트가 생성된 후 레시컬 환경이 완성된 뒤 실행 컨텍스트 스택에 최상위 스택으로서 적재되빈다.
2. 함수 실행 컨텍스트를 함수 렉시컬 환경에 바인딩 후 환경 레코드를 생성하고, this 또한 바인딩 합니다.
3. 외부 렉시컬 환경은 전역 렉시컬 환경을 참조하게 되는데, 그 이유는 해당 함수는 전역 코드에서 정의된 전역 함수이기 때문에 평가되는 시점에서는 전역 실행 컨텍스트가 실행되기 때문이며, 해당 상위 스코프는 함수 객체의 내부 슬롯인 [[Environment]]에 저장합니다.

```


```

① 예제로 알아보는 실행 컨텍스트 절차) 전역 코드 등록 및 실행

var x = 1; // BindObject 객체에 의해 전역 객체의 프로퍼티인 var x 식별자로 등록되는 동시에 undefined 값 할당하고 런타임 때에 var x를 렉시컬 환경에서 검색 후 존재하면 1을 할당
const y = 2; // 외부 렉시컬 참조에 의해 값이 전혀 없고 단지 const y 식별자로만 등록되므로 호출이 불가능하며 런타임 때에 비로소 렉시컬 환경에서 검색하고 있을 경우 2를 할당.

function reformVars(a){ // BindObject 객체에 의해 전역 객체의 메서드 등록
    var x = 3;
    const y = 4
    function addNumbers(b){
        const z = 5;
        console.log(a+b+x+y+z);
    }
    addNumbers(10);
}
reformVars(20); // 함수 호출문이므로 등록을 안하고 런타임때에 해당 코드문을 만날때 해당 함수를 호출

② 예제로 알아보는 실행 컨텍스트 절차) reformVars 함수 호출시

var x = 1; 
const y = 2; 

function reformVars(a){ // 해당 함수에 대한 실행 컨텍스트 작업 시작
    var x = 3; // 해당 함수의 지역 변수로서 함수 렉시컬 환경에 등록되고 undefined 할당 후 런타임 때에 서칭 후 3 할당
    const y = 4 // 해당 함수의 지역 변수로서 함수 렉시컬 환경에 등록만 되고 런타임 때에 서칭 후 3 할당
    function addNumbers(b){ // function addNumbers 함수를 등록
        const z = 5;
        console.log(a+b+x+y+z);
    }
    addNumbers(10); // 함수 호출문이므로 등록은 안하고 런타임때 호출
}
reformVars(20); // 

③ 예제로 알아보는 실행 컨텍스트 절차) addNumbers 함수 호출시

var x = 1; 
const y = 2; 

function reformVars(a){ 
    var x = 3; 
    const y = 4 
    function addNumbers(b){ 
        const z = 5; //상기 설명과 동일
        console.log(a+b+x+y+z); // 스코프 체인을 따라 해당 메서드를 검색하는데, 해당 렉시컬 환경에도 없으면 reformVars 렉시컬 환경에서도 검색 후 없으면 스코프 체인상 최상단에 위치한 전역 실행 컨텍스트의 렉시컬 환경이 바인딩 하는 전역 객체의 프로퍼티 요소인 메서드인 console.log 메서드를 검색 후 표현식을 평가하는데, 이때 a는 reformVars의 렉시컬 환경에서, b는 addNumbers 렉시컬 환경에서, x와 y는 addNumbers의 상위 스코프인 reformVars 렉시컬 환경에서, z는 addNumbers의 렉시컬 환경에서 검색후 해당 표현식을 연산처리 하게 됩니다.
    }
    addNumbers(10);
}
reformVars(20);

★ 실행 컨텍스트 스택에 적재되어 있던 특정 컨텍스트에서 더 이상 실행할 코드가 없다면 위의 함수들을 종료시킬텐데, 이때 스택에서 실행 컨텍스가 제거되었다고 해서 렉시컬 환경까지 제거되는 것은 아니며, 해당 렉시컬 환경을 참조하는 외부 객체가 있다면 유지되고, 참조하는 객체가 아무도 없을 때에 가비지 컬렉터에 의해 소멸됩니다.

```


